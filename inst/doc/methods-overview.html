<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Evgeni Chasnovski" />

<meta name="date" content="2018-05-29" />

<title>Methods Overview</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Methods Overview</h1>
<h4 class="author"><em>Evgeni Chasnovski</em></h4>
<h4 class="date"><em>2018-05-29</em></h4>



<p><code>comperank</code> provides tools for computing ranking and rating based on competition results. It is tightly connected to its data infrastructure package <a href="https://github.com/echasnovski/comperes">comperes</a>. Basic knowledge about creating <a href="https://github.com/echasnovski/comperes#store-and-convert">valid competition results</a> and <a href="https://github.com/echasnovski/comperes#head-to-head">Head-to-Head expressions</a> with <code>comperes</code> is needed in order to efficiently use <code>comperank</code>.</p>
<p>Understanding of <strong>competition</strong> is quite general: it is a set of <strong>games</strong> (abstract event) in which <strong>players</strong> (abstract entity) gain some abstract <strong>scores</strong> (typically numeric). The most natural example is sport results, however not the only one. Product rating can also be considered as a competition between products as “players”. Here a “game” is a customer that reviews a set of products by rating them with numerical “score” (stars, points, etc.).</p>
<p><strong>Rating</strong> is a list (in the ordinary sense) of numerical values, one for each player, or the numerical value itself. Its interpretation depends on rating method: either bigger value indicates better player performance or otherwise.</p>
<p><strong>Ranking</strong> is a rank-ordered list (in the ordinary sense) of players: rank 1 indicates player with best performance.</p>
<p><code>comperank</code> leverages the <a href="https://www.tidyverse.org/">tidyverse</a> ecosystem of R packages. Among other things, it means that the main output format is <a href="http://tibble.tidyverse.org/">tibble</a>.</p>
<div id="overview" class="section level2">
<h2>Overview</h2>
<p><code>comperank</code> gets inspiration from the book <a href="https://www.amazon.com/Whos-1-Science-Rating-Ranking/dp/069116231X">“Who’s #1”</a> by Langville and Meyer. It provides functionality for the following rating algorithms:</p>
<ul>
<li>Algorithms with <strong>fixed Head-to-Head structure</strong>:
<ul>
<li>Simplified Massey method with <code>rate_massey()</code> and <code>rank_massey()</code>.</li>
<li>Simplified Colley method with <code>rate_colley()</code> and <code>rank_colley()</code>.</li>
</ul></li>
<li>Algorithms with <strong>variable Head-to-Head structure</strong>:
<ul>
<li>Keener method with <code>rate_keener()</code> and <code>rank_keener()</code>.</li>
<li>Markov method with <code>rate_markov()</code> and <code>rank_markov()</code>.</li>
<li>Offense-Defense method with <code>rate_od()</code> and <code>rank_od()</code>.</li>
</ul></li>
<li>Algorithms with <strong>iterative nature</strong>:
<ul>
<li>General Iterative ratings with <code>rate_iterative()</code>, <code>rank_iterative()</code>, and <code>add_iterative_ratings()</code>.</li>
<li>Elo ratings with <code>rate_elo()</code>, <code>rank_elo()</code>, and <code>add_elo_ratings()</code>.</li>
</ul></li>
</ul>
<p>As you can see, there are three sets of functions:</p>
<ul>
<li><code>rate_*()</code>. Its output is a tibble with columns <code>player</code> (player identifier) and at least one <code>rating_*</code> (rating value). Names of rating columns depend on rating method.</li>
<li><code>rank_*()</code>. Its default output is similar to previous one, but with <code>ranking_*</code> instead of rating columns. It runs <code>rate_*()</code> and does ranking with correct direction. One can use option <code>keep_rating = TRUE</code> to keep rating columns in the output.</li>
<li><code>add_*_ratings()</code>. These functions are present only for algorithms with iterative nature and competition results with games only between two players. They return tibble with row corresponding to a game and extra columns indicating ratings of players before and after the game.</li>
</ul>
<p>This vignette provides examples of basic usage of these functions. To learn more about algorithms behind them, see corresponding help pages.</p>
<p>For this vignette we will need the following packages:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)

<span class="co"># This also loads comperes package</span>
<span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(comperank))</code></pre></div>
</div>
<div id="structure-of-competition-results" class="section level2">
<h2>Structure of competition results</h2>
<p>All functions in <code>comperank</code> expect competition results in one of the formats from <code>comperes</code> package. That is either <strong>long</strong> or <strong>wide</strong> format.</p>
<p><strong>Long format</strong> is the most abstract way of presenting competition results. Basically, it is a data frame (or tibble) with columns <code>game</code> (game identifier), <code>player</code> (player identifier) and <code>score</code> where <em>each row represents the score of particular player in particular game</em>. One game can consist from <strong>variable</strong> number of players which makes this format more usable. Inside a game all players are treated equally.</p>
<p>Programmatically long format is represented with <code>longcr</code> S3 class which should be created with <code>as_longcr()</code> function from <code>comperes</code>.</p>
<p>For examples we will use <code>ncaa2005</code> data set from <code>comperes</code> package, which is already of <code>longcr</code> class. It is an example competition results of an isolated group of Atlantic Coast Conference teams provided in book <strong>“Who’s #1”</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ncaa2005
<span class="co">#&gt; # A longcr object:</span>
<span class="co">#&gt; # A tibble: 20 x 3</span>
<span class="co">#&gt;     game player score</span>
<span class="co">#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;int&gt;</span>
<span class="co">#&gt;  1     1 Duke       7</span>
<span class="co">#&gt;  2     1 Miami     52</span>
<span class="co">#&gt;  3     2 Duke      21</span>
<span class="co">#&gt;  4     2 UNC       24</span>
<span class="co">#&gt;  5     3 Duke       7</span>
<span class="co">#&gt;  6     3 UVA       38</span>
<span class="co">#&gt;  7     4 Duke       0</span>
<span class="co">#&gt;  8     4 VT        45</span>
<span class="co">#&gt;  9     5 Miami     34</span>
<span class="co">#&gt; 10     5 UNC       16</span>
<span class="co">#&gt; 11     6 Miami     25</span>
<span class="co">#&gt; 12     6 UVA       17</span>
<span class="co">#&gt; 13     7 Miami     27</span>
<span class="co">#&gt; 14     7 VT         7</span>
<span class="co">#&gt; 15     8 UNC        7</span>
<span class="co">#&gt; 16     8 UVA        5</span>
<span class="co">#&gt; 17     9 UNC        3</span>
<span class="co">#&gt; 18     9 VT        30</span>
<span class="co">#&gt; 19    10 UVA       14</span>
<span class="co">#&gt; 20    10 VT        52</span></code></pre></div>
<p><strong>Wide format</strong> is a more convenient way to store results with <strong>fixed</strong> number of players in a game. <em>Each row represents scores of all players in particular game</em>. Data should be organized in pairs of columns “player”-“score”. Identifier of a pair should go after respective keyword and consist only from digits. For example: <code>player1</code>, <code>score1</code>, <code>player2</code>, <code>score2</code>. Order doesn’t matter. Column <code>game</code> is optional.</p>
<p>Programmatically wide format is represented with <code>widecr</code> S3 class which should be created with <code>as_widecr()</code> function from <code>comperes</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">comperes<span class="op">::</span><span class="kw">as_widecr</span>(ncaa2005)
<span class="co">#&gt; # A widecr object:</span>
<span class="co">#&gt; # A tibble: 10 x 5</span>
<span class="co">#&gt;     game player1 score1 player2 score2</span>
<span class="co">#&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt;</span>
<span class="co">#&gt;  1     1 Duke         7 Miami       52</span>
<span class="co">#&gt;  2     2 Duke        21 UNC         24</span>
<span class="co">#&gt;  3     3 Duke         7 UVA         38</span>
<span class="co">#&gt;  4     4 Duke         0 VT          45</span>
<span class="co">#&gt;  5     5 Miami       34 UNC         16</span>
<span class="co">#&gt;  6     6 Miami       25 UVA         17</span>
<span class="co">#&gt;  7     7 Miami       27 VT           7</span>
<span class="co">#&gt;  8     8 UNC          7 UVA          5</span>
<span class="co">#&gt;  9     9 UNC          3 VT          30</span>
<span class="co">#&gt; 10    10 UVA         14 VT          52</span></code></pre></div>
<p><strong>All <code>comperank</code> functions expect either a data frame with long format structure, or <code>longcr</code> object, or <code>widecr</code> object</strong>.</p>
</div>
<div id="algorithms-with-fixed-head-to-head-structure" class="section level2">
<h2>Algorithms with fixed Head-to-Head structure</h2>
<p><strong>Massey</strong> and <strong>Colley</strong> methods were initially designed for competitions where:</p>
<ul>
<li>Games are held only between two players.</li>
<li>It is assumed that score is numeric and higher values indicate better player performance in a game.</li>
</ul>
<div id="massey-method" class="section level3">
<h3>Massey method</h3>
<p>Idea of Massey method is that difference in ratings should be proportional to score difference in direct confrontations. Bigger value indicates better player competition performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rate_massey</span>(ncaa2005)
<span class="co">#&gt; # A tibble: 5 x 2</span>
<span class="co">#&gt;   player rating_massey</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke           -24.8</span>
<span class="co">#&gt; 2 Miami           18.2</span>
<span class="co">#&gt; 3 UNC             -8. </span>
<span class="co">#&gt; 4 UVA             -3.4</span>
<span class="co">#&gt; 5 VT              18</span>

<span class="kw">rank_massey</span>(ncaa2005)
<span class="co">#&gt; # A tibble: 5 x 2</span>
<span class="co">#&gt;   player ranking_massey</span>
<span class="co">#&gt;   &lt;chr&gt;           &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke                5</span>
<span class="co">#&gt; 2 Miami               1</span>
<span class="co">#&gt; 3 UNC                 4</span>
<span class="co">#&gt; 4 UVA                 3</span>
<span class="co">#&gt; 5 VT                  2</span>

<span class="kw">rank_massey</span>(ncaa2005, <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_massey ranking_massey</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke           -24.8              5</span>
<span class="co">#&gt; 2 Miami           18.2              1</span>
<span class="co">#&gt; 3 UNC             -8.               4</span>
<span class="co">#&gt; 4 UVA             -3.4              3</span>
<span class="co">#&gt; 5 VT              18                2</span></code></pre></div>
</div>
<div id="colley-method" class="section level3">
<h3>Colley method</h3>
<p>Idea of Colley method is that ratings should be proportional to share of player’s won games. Bigger value indicates better player performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rank_colley</span>(ncaa2005, <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_colley ranking_colley</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke           0.214              5</span>
<span class="co">#&gt; 2 Miami          0.786              1</span>
<span class="co">#&gt; 3 UNC            0.5                3</span>
<span class="co">#&gt; 4 UVA            0.357              4</span>
<span class="co">#&gt; 5 VT             0.643              2</span></code></pre></div>
</div>
</div>
<div id="algorithms-with-variable-head-to-head-structure" class="section level2">
<h2>Algorithms with variable Head-to-Head structure</h2>
<p>All algorithms with variable Head-to-Head structure depend on user supplying custom Head-to-Head expression for computing quality of direct confrontations between all pairs of players of interest.</p>
<p>Computation of Head-to-Head values is done with functionality of <code>comperes</code> package. Programmatically it is implemented as summary of players’ matchups - mini-“games” in <code>widecr</code> format between pair of players. In other words, for every directed pair (order matters) of players (including “pair” of player with oneself):</p>
<ul>
<li>Data frame of matchups is computed in wide format, i.e. with columns <code>game</code>, <code>player1</code>, <code>score1</code>, <code>player2</code>, <code>score2</code>.</li>
<li>This data frame is summarised with Head-to-Head expression supplied in <a href="http://dplyr.tidyverse.org/">dplyr</a> fashion.</li>
</ul>
<p>For more robust usage <code>comperes</code> provides <code>h2h_funs</code> - a list of the most common Head-to-Head <a href="http://rlang.r-lib.org/reference/quotation.html">expressions</a> which are designed to be used with <a href="http://rlang.r-lib.org/">rlang</a>’s <a href="http://rlang.r-lib.org/reference/quasiquotation.html">unquoting</a> mechanism. All <code>comperank</code> functions are designed to be used smoothly with it.</p>
<p>Examples of computing Head-to-Head values for more clarity:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Examples of h2h_funs elements</span>
<span class="kw">names</span>(h2h_funs)
<span class="co">#&gt; [1] &quot;mean_score_diff&quot;     &quot;mean_score_diff_pos&quot; &quot;mean_score&quot;         </span>
<span class="co">#&gt; [4] &quot;sum_score_diff&quot;      &quot;sum_score_diff_pos&quot;  &quot;sum_score&quot;          </span>
<span class="co">#&gt; [7] &quot;num_wins&quot;            &quot;num_wins2&quot;           &quot;num&quot;</span>

h2h_funs[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]
<span class="co">#&gt; $mean_score_diff</span>
<span class="co">#&gt; mean(score1 - score2)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $mean_score_diff_pos</span>
<span class="co">#&gt; max(mean(score1 - score2), 0)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $mean_score</span>
<span class="co">#&gt; mean(score1)</span>

<span class="co"># Computing Head-to-Head values with unquoting</span>
comperes<span class="op">::</span><span class="kw">h2h_long</span>(ncaa2005, <span class="op">!!!</span><span class="st"> </span>h2h_funs)
<span class="co">#&gt; # A long format of Head-to-Head values:</span>
<span class="co">#&gt; # A tibble: 25 x 11</span>
<span class="co">#&gt;    player1 player2 mean_score_diff mean_score_diff_pos mean_score</span>
<span class="co">#&gt;    &lt;chr&gt;   &lt;chr&gt;             &lt;dbl&gt;               &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt;  1 Duke    Duke                  0                   0       8.75</span>
<span class="co">#&gt;  2 Duke    Miami               -45                   0       7   </span>
<span class="co">#&gt;  3 Duke    UNC                  -3                   0      21   </span>
<span class="co">#&gt;  4 Duke    UVA                 -31                   0       7   </span>
<span class="co">#&gt;  5 Duke    VT                  -45                   0       0   </span>
<span class="co">#&gt;  6 Miami   Duke                 45                  45      52   </span>
<span class="co">#&gt;  7 Miami   Miami                 0                   0      34.5 </span>
<span class="co">#&gt;  8 Miami   UNC                  18                  18      34   </span>
<span class="co">#&gt;  9 Miami   UVA                   8                   8      25   </span>
<span class="co">#&gt; 10 Miami   VT                   20                  20      27   </span>
<span class="co">#&gt; # ... with 15 more rows, and 6 more variables: sum_score_diff &lt;int&gt;,</span>
<span class="co">#&gt; #   sum_score_diff_pos &lt;dbl&gt;, sum_score &lt;int&gt;, num_wins &lt;dbl&gt;,</span>
<span class="co">#&gt; #   num_wins2 &lt;dbl&gt;, num &lt;int&gt;</span>

comperes<span class="op">::</span><span class="kw">h2h_mat</span>(ncaa2005, <span class="op">!!!</span><span class="st"> </span>h2h_funs[<span class="st">&quot;mean_score&quot;</span>])
<span class="co">#&gt; # A matrix format of Head-to-Head values:</span>
<span class="co">#&gt;        Duke Miami  UNC  UVA   VT</span>
<span class="co">#&gt; Duke   8.75   7.0 21.0  7.0  0.0</span>
<span class="co">#&gt; Miami 52.00  34.5 34.0 25.0 27.0</span>
<span class="co">#&gt; UNC   24.00  16.0 12.5  7.0  3.0</span>
<span class="co">#&gt; UVA   38.00  17.0  5.0 18.5 14.0</span>
<span class="co">#&gt; VT    45.00   7.0 30.0 52.0 33.5</span>

<span class="co"># Computing Head-to-Head values manually</span>
comperes<span class="op">::</span><span class="kw">h2h_mat</span>(ncaa2005, <span class="kw">mean</span>(score1))
<span class="co">#&gt; # A matrix format of Head-to-Head values:</span>
<span class="co">#&gt;        Duke Miami  UNC  UVA   VT</span>
<span class="co">#&gt; Duke   8.75   7.0 21.0  7.0  0.0</span>
<span class="co">#&gt; Miami 52.00  34.5 34.0 25.0 27.0</span>
<span class="co">#&gt; UNC   24.00  16.0 12.5  7.0  3.0</span>
<span class="co">#&gt; UVA   38.00  17.0  5.0 18.5 14.0</span>
<span class="co">#&gt; VT    45.00   7.0 30.0 52.0 33.5</span>

<span class="co"># To account for self play use `if-else`</span>
comperes<span class="op">::</span><span class="kw">h2h_mat</span>(ncaa2005, <span class="cf">if</span>(player1[<span class="dv">1</span>] <span class="op">==</span><span class="st"> </span>player2[<span class="dv">1</span>]) <span class="dv">0</span> <span class="cf">else</span> <span class="kw">mean</span>(score1))
<span class="co">#&gt; # A matrix format of Head-to-Head values:</span>
<span class="co">#&gt;       Duke Miami UNC UVA VT</span>
<span class="co">#&gt; Duke     0     7  21   7  0</span>
<span class="co">#&gt; Miami   52     0  34  25 27</span>
<span class="co">#&gt; UNC     24    16   0   7  3</span>
<span class="co">#&gt; UVA     38    17   5   0 14</span>
<span class="co">#&gt; VT      45     7  30  52  0</span></code></pre></div>
<p>All functions for methods with variable Head-to-Head structure are designed with this rule in mind: <strong>the more Head-to-Head value the better player1 performed than player2</strong>.</p>
<div id="keener-method" class="section level3">
<h3>Keener method</h3>
<p>Keener method is based on the idea of “relative strength” - the strength of the player relative to the strength of the players he/she has played against. This is computed based on provided Head-to-Head values and some flexible algorithmic adjustments to make method more robust. Bigger value indicates better player performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rank_keener</span>(ncaa2005, <span class="op">!!!</span><span class="st"> </span>h2h_funs[<span class="st">&quot;mean_score&quot;</span>], <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_keener ranking_keener</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke          0.0671              5</span>
<span class="co">#&gt; 2 Miami         0.351               1</span>
<span class="co">#&gt; 3 UNC           0.158               4</span>
<span class="co">#&gt; 4 UVA           0.161               3</span>
<span class="co">#&gt; 5 VT            0.263               2</span></code></pre></div>
</div>
<div id="markov-method" class="section level3">
<h3>Markov method</h3>
<p>The main idea of Markov method is that players “vote” for other players’ performance. Voting is done with Head-to-Head values and the more value the more “votes” gives player2 to player1. For example, if Head-to-Head value is “number of wins” then player2 “votes” for player1 proportionally to number of times player1 won in a matchup with player2. <strong>Beware</strong> of careful consideration of Head-to-Head values for self plays.</p>
<p>Actual “voting” is done in <a href="https://en.wikipedia.org/wiki/Markov_chain">Markov chain</a> fashion: Head-to-Head values are organized in stochastic matrix which vector of stationary probabilities is declared to be output ratings. Bigger value indicates better player performance.</p>
<p>As stochastic matrices can be averaged (with weights), this is the only method capable of direct averaging ratings for different Head-to-Head expressions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rank_markov</span>(ncaa2005, <span class="op">!!!</span><span class="st"> </span>h2h_funs[<span class="st">&quot;num_wins&quot;</span>], <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_markov ranking_markov</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke          0.0991              5</span>
<span class="co">#&gt; 2 Miami         0.407               1</span>
<span class="co">#&gt; 3 UNC           0.154               3</span>
<span class="co">#&gt; 4 UVA           0.120               4</span>
<span class="co">#&gt; 5 VT            0.220               2</span>

<span class="kw">rank_markov</span>(
  ncaa2005,
  <span class="op">!!!</span><span class="st"> </span>h2h_funs[<span class="kw">c</span>(<span class="st">&quot;num_wins&quot;</span>, <span class="st">&quot;mean_score_diff_pos&quot;</span>)],
  <span class="dt">weights =</span> <span class="kw">c</span>(<span class="fl">0.2</span>, <span class="fl">0.8</span>),
  <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>
)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_markov ranking_markov</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke          0.0994              5</span>
<span class="co">#&gt; 2 Miami         0.408               1</span>
<span class="co">#&gt; 3 UNC           0.115               4</span>
<span class="co">#&gt; 4 UVA           0.120               3</span>
<span class="co">#&gt; 5 VT            0.257               2</span></code></pre></div>
</div>
<div id="offense-defense-method" class="section level3">
<h3>Offense-Defense method</h3>
<p>The idea of Offense-Defense (OD) method is to account for different abilities of players by combining different ratings:</p>
<ul>
<li>For player which can achieve <em>high</em> Head-to-Head value (even against the player with strong defense) it is said that he/she has <strong>strong offense</strong> which results into <em>high</em> offensive rating.</li>
<li>For player which can force their opponents into achieving <em>low</em> Head-to-Head value (even if they have strong offense) it is said that he/she has <strong>strong defense</strong> which results into <em>low</em> defensive rating.</li>
</ul>
<p>Offensive and defensive ratings describe different skills of players. In order to fully rate players, OD ratings are computed: offensive ratings divided by defensive. The more OD rating the better player performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rank_od</span>(
  ncaa2005,
  <span class="cf">if</span> (player1[<span class="dv">1</span>] <span class="op">==</span><span class="st"> </span>player2[<span class="dv">1</span>]) <span class="dv">0</span> <span class="cf">else</span> <span class="kw">mean</span>(score1),
  <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>
)
<span class="co">#&gt; # A tibble: 5 x 7</span>
<span class="co">#&gt;   player rating_off rating_def rating_od ranking_off ranking_def</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke         34.0      1.69       20.1           5           5</span>
<span class="co">#&gt; 2 Miami       152.       0.803     189.            1           2</span>
<span class="co">#&gt; 3 UNC          48.7      1.16       41.8           4           4</span>
<span class="co">#&gt; 4 UVA          82.0      0.967      84.8           3           3</span>
<span class="co">#&gt; 5 VT          115.       0.411     280.            2           1</span>
<span class="co">#&gt; # ... with 1 more variable: ranking_od &lt;dbl&gt;</span></code></pre></div>
</div>
</div>
<div id="algorithms-with-iterative-nature" class="section level2">
<h2>Algorithms with iterative nature</h2>
<p>Rating methods with iterative nature assume that games occur in some particular order. All players have some initial ratings which are updated after every game in order they appear. Although, it is possible to consider games with more than two players, <code>comperank</code> only supports competition results with all games between two players.</p>
<div id="iterative-ratings" class="section level3">
<h3>Iterative ratings</h3>
<p>Iterative ratings represent the general approach to ratings with iterative nature. It needs custom rating function and initial player ratings to perform iterative ratings computation. Rating function should accept four arguments: <code>rating1</code> (scalar rating of the first player before the game), <code>score1</code> (his score), <code>rating2</code> and <code>score2</code> for the data about second player’s performance. It should return a numeric vector of length 2 with elements respectively representing ratings of players after the game.</p>
<p>All functions assume that the order in which games were played is identical to order of values in column <code>game</code> (if present) or is defined by the row order.</p>
<p>Arguably, the most useful function is <code>add_iterative_ratings()</code>, which adds to <code>widecr</code> format of competition results information about game ratings before and after the game.</p>
<p><code>rate_iterative()</code> and <code>rank_iterative()</code> return ratings after the last game.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Adds 1 to winner's rating and subtracts 1 from loser's rating</span>
test_rate_fun &lt;-<span class="st"> </span><span class="cf">function</span>(rating1, score1, rating2, score2) {
  <span class="kw">c</span>(rating1, rating2) <span class="op">+</span><span class="st"> </span>((score1 <span class="op">&gt;=</span><span class="st"> </span>score2) <span class="op">*</span><span class="st"> </span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)
}
<span class="kw">add_iterative_ratings</span>(ncaa2005, test_rate_fun)
<span class="co">#&gt; # A widecr object:</span>
<span class="co">#&gt; # A tibble: 10 x 9</span>
<span class="co">#&gt;     game player1 score1 player2 score2 rating1Before rating2Before</span>
<span class="co">#&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt;  1     1 Duke         7 Miami       52             0             0</span>
<span class="co">#&gt;  2     2 Duke        21 UNC         24            -1             0</span>
<span class="co">#&gt;  3     3 Duke         7 UVA         38            -2             0</span>
<span class="co">#&gt;  4     4 Duke         0 VT          45            -3             0</span>
<span class="co">#&gt;  5     5 Miami       34 UNC         16             1             1</span>
<span class="co">#&gt;  6     6 Miami       25 UVA         17             2             1</span>
<span class="co">#&gt;  7     7 Miami       27 VT           7             3             1</span>
<span class="co">#&gt;  8     8 UNC          7 UVA          5             0             0</span>
<span class="co">#&gt;  9     9 UNC          3 VT          30             1             0</span>
<span class="co">#&gt; 10    10 UVA         14 VT          52            -1             1</span>
<span class="co">#&gt; # ... with 2 more variables: rating1After &lt;dbl&gt;, rating2After &lt;dbl&gt;</span>

<span class="co"># Revert the order of games</span>
ncaa2005_rev &lt;-<span class="st"> </span>ncaa2005
ncaa2005_rev<span class="op">$</span>game &lt;-<span class="st"> </span><span class="dv">11</span> <span class="op">-</span><span class="st"> </span>ncaa2005_rev<span class="op">$</span>game
<span class="kw">add_iterative_ratings</span>(ncaa2005_rev, test_rate_fun)
<span class="co">#&gt; # A widecr object:</span>
<span class="co">#&gt; # A tibble: 10 x 9</span>
<span class="co">#&gt;     game player1 score1 player2 score2 rating1Before rating2Before</span>
<span class="co">#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt;  1     1 UVA         14 VT          52             0             0</span>
<span class="co">#&gt;  2     2 UNC          3 VT          30             0             1</span>
<span class="co">#&gt;  3     3 UNC          7 UVA          5            -1            -1</span>
<span class="co">#&gt;  4     4 Miami       27 VT           7             0             2</span>
<span class="co">#&gt;  5     5 Miami       25 UVA         17             1            -2</span>
<span class="co">#&gt;  6     6 Miami       34 UNC         16             2             0</span>
<span class="co">#&gt;  7     7 Duke         0 VT          45             0             1</span>
<span class="co">#&gt;  8     8 Duke         7 UVA         38            -1            -3</span>
<span class="co">#&gt;  9     9 Duke        21 UNC         24            -2            -1</span>
<span class="co">#&gt; 10    10 Duke         7 Miami       52            -3             3</span>
<span class="co">#&gt; # ... with 2 more variables: rating1After &lt;dbl&gt;, rating2After &lt;dbl&gt;</span>

<span class="co"># Rating after the last game</span>
<span class="kw">rank_iterative</span>(ncaa2005, test_rate_fun, <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_iterative ranking_iterative</span>
<span class="co">#&gt;   &lt;chr&gt;             &lt;dbl&gt;             &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke                 -4                 5</span>
<span class="co">#&gt; 2 Miami                 4                 1</span>
<span class="co">#&gt; 3 UNC                   0                 3</span>
<span class="co">#&gt; 4 UVA                  -2                 4</span>
<span class="co">#&gt; 5 VT                    2                 2</span></code></pre></div>
</div>
<div id="elo-method" class="section level3">
<h3>Elo method</h3>
<p>Elo method is, basically, an iterative rating method with fixed <a href="https://en.wikipedia.org/wiki/Elo_rating_system">Elo</a> rating function. General idea is that rating increase for winner should be the bigger the more is rating difference between players. In other words, win over a better player should lead to more rating increase and win over a considerably weaker player shouldn’t affect rating that much.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">add_elo_ratings</span>(ncaa2005)
<span class="co">#&gt; # A widecr object:</span>
<span class="co">#&gt; # A tibble: 10 x 9</span>
<span class="co">#&gt;     game player1 score1 player2 score2 rating1Before rating2Before</span>
<span class="co">#&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt;  1     1 Duke         7 Miami       52         0             0    </span>
<span class="co">#&gt;  2     2 Duke        21 UNC         24       -15             0    </span>
<span class="co">#&gt;  3     3 Duke         7 UVA         38       -29.4           0    </span>
<span class="co">#&gt;  4     4 Duke         0 VT          45       -43.1           0    </span>
<span class="co">#&gt;  5     5 Miami       34 UNC         16        15            14.4  </span>
<span class="co">#&gt;  6     6 Miami       25 UVA         17        30.0          13.7  </span>
<span class="co">#&gt;  7     7 Miami       27 VT           7        44.3          13.1  </span>
<span class="co">#&gt;  8     8 UNC          7 UVA          5        -0.619        -0.564</span>
<span class="co">#&gt;  9     9 UNC          3 VT          30        14.4          -0.511</span>
<span class="co">#&gt; 10    10 UVA         14 VT          52       -15.6          15.1  </span>
<span class="co">#&gt; # ... with 2 more variables: rating1After &lt;dbl&gt;, rating2After &lt;dbl&gt;</span>
<span class="kw">add_elo_ratings</span>(ncaa2005_rev)
<span class="co">#&gt; # A widecr object:</span>
<span class="co">#&gt; # A tibble: 10 x 9</span>
<span class="co">#&gt;     game player1 score1 player2 score2 rating1Before rating2Before</span>
<span class="co">#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt;  1     1 UVA         14 VT          52           0           0    </span>
<span class="co">#&gt;  2     2 UNC          3 VT          30           0          15    </span>
<span class="co">#&gt;  3     3 UNC          7 UVA          5         -14.4       -15    </span>
<span class="co">#&gt;  4     4 Miami       27 VT           7           0          29.4  </span>
<span class="co">#&gt;  5     5 Miami       25 UVA         17          16.3       -30.0  </span>
<span class="co">#&gt;  6     6 Miami       34 UNC         16          29.3         0.619</span>
<span class="co">#&gt;  7     7 Duke         0 VT          45           0          13.1  </span>
<span class="co">#&gt;  8     8 Duke         7 UVA         38         -14.4       -43.0  </span>
<span class="co">#&gt;  9     9 Duke        21 UNC         24         -30.7       -13.1  </span>
<span class="co">#&gt; 10    10 Duke         7 Miami       52         -44.9        43.0  </span>
<span class="co">#&gt; # ... with 2 more variables: rating1After &lt;dbl&gt;, rating2After &lt;dbl&gt;</span>

<span class="kw">rank_elo</span>(ncaa2005, <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_elo ranking_elo</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke       -56.2            5</span>
<span class="co">#&gt; 2 Miami       57.9            1</span>
<span class="co">#&gt; 3 UNC         -1.26           3</span>
<span class="co">#&gt; 4 UVA        -29.2            4</span>
<span class="co">#&gt; 5 VT          28.8            2</span>
<span class="kw">rank_elo</span>(ncaa2005_rev, <span class="dt">keep_rating =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;   player rating_elo ranking_elo</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Duke       -56.2            5</span>
<span class="co">#&gt; 2 Miami       54.3            1</span>
<span class="co">#&gt; 3 UNC          1.10           3</span>
<span class="co">#&gt; 4 UVA        -26.8            4</span>
<span class="co">#&gt; 5 VT          27.5            2</span></code></pre></div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
